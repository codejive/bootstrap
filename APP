#!/bin/bash

# --- Configuration (Non-Overridable) ---
APP_NAME="APP"
APP_DIR=".APP"
DOWNLOAD_URL="https://example.com/releases/.../foo-latest.tgz"
# ---------------------------------------

# 1. Setup essential variables needed for config loading
HOME_DIR="$HOME"
APP_HOME="$HOME_DIR/$APP_DIR"

# 2. Define default overridable variables
# The update period in days (e.g., 3 means check if the last_checked file is older than 3 days)
UPDATE_PERIOD=3
# Logging level (default empty/silent; set to anything, e.g., 'DEBUG', to enable logging)
LOG_LEVEL=

# --- Configuration Loading ---
# Function to load configuration variables from a file
load_config() {
    local config_file="$1"
    if [ -f "$config_file" ]; then
        #LOG "Loading configuration from $config_file..."
        source "$config_file" 2>/dev/null
    fi
}

# Load user-wide configuration (if exists)
load_config "$APP_HOME/bootstrap.cfg"

# Load local configuration (if exists)
load_config "./$APP_DIR/bootstrap.cfg"

# -----------------------------

# 3. Define the remaining path variables using the (potentially overridden) APP_NAME/UPDATE_PERIOD
CACHE_DIR="$APP_HOME/_cache"
BIN_DIR="$APP_HOME/bin"
APP_EXE="$BIN_DIR/$APP_NAME"
ARCHIVE_FILE="$CACHE_DIR/release.tgz"
LAST_CHECKED_FILE="$CACHE_DIR/last_checked"

LOG() {
    # Only echo the log message if LOG_LEVEL is not empty
    if [ -n "$LOG_LEVEL" ]; then
        echo "[$APP_NAME Bootstrap] $1"
    fi
}

# Function to get the last modification timestamp of a file
get_file_mtime() {
    # Use stat command for reliable cross-platform (Linux/Mac) date retrieval
    # Linux: 'stat -c %Y' for seconds since epoch
    # macOS: 'stat -f %m' for seconds since epoch
    if command -v gstat &> /dev/null; then
        # Use GNU stat if available (e.g., via MacPorts/Homebrew)
        gstat -c %Y "$1" 2>/dev/null
    elif uname | grep -q "Darwin"; then
        # macOS
        stat -f %m "$1" 2>/dev/null
    else
        # Standard Linux
        stat -c %Y "$1" 2>/dev/null
    fi
}

# --- Core Logic Functions ---

perform_full_install() {
    LOG "Application not found or update forced. Starting download and install..."

    # 1. Setup directories
    mkdir -p "$CACHE_DIR" || { LOG "Error: Could not create cache directory $CACHE_DIR"; exit 1; }

    # 2. Download the release archive
    LOG "Downloading $DOWNLOAD_URL..."
    # The --remote-time (-r) option ensures the local file date matches the remote server's date.
    if ! curl -fsSL --remote-time "$DOWNLOAD_URL" -o "$ARCHIVE_FILE"; then
        LOG "Error: Download failed for $DOWNLOAD_URL."
        exit 1
    fi

    # 3. Unpack and clean up
    LOG "Unpacking application..."
    # Remove existing installation directory if it exists before unpacking
    rm -rf "$APP_HOME/temp_install"
    mkdir -p "$APP_HOME/temp_install"

    if ! tar -xzf "$ARCHIVE_FILE" -C "$APP_HOME/temp_install"; then
        LOG "Error: Failed to unpack archive $ARCHIVE_FILE."
        rm -rf "$APP_HOME/temp_install"
        exit 1
    fi

    # Find the top-level directory inside the archive (often matches the APP_NAME)
    # Move the contents of the single directory inside the archive to the app home
    # Assuming the archive unpacks to a single directory (e.g., 'foo-v1.0')
    UNPACKED_ROOT=$(find "$APP_HOME/temp_install" -mindepth 1 -maxdepth 1 -type d -print -quit)

    if [ -d "$UNPACKED_ROOT" ]; then
        # Move contents of the single directory to APP_HOME
        LOG "Moving contents from $UNPACKED_ROOT to $APP_HOME"
        # Move all contents, excluding the original temp directory itself
        mv "$UNPACKED_ROOT"/* "$APP_HOME" 2>/dev/null
        mv "$UNPACKED_ROOT"/.* "$APP_HOME" 2>/dev/null # Move hidden files/dirs too
    else
        # If no single directory, move all contents of temp_install to APP_HOME
        LOG "Moving contents directly from $APP_HOME/temp_install to $APP_HOME"
        mv "$APP_HOME/temp_install"/* "$APP_HOME" 2>/dev/null
        mv "$APP_HOME/temp_install"/.* "$APP_HOME" 2>/dev/null # Move hidden files/dirs too
    fi

    # Clean up the temporary directory
    rm -rf "$APP_HOME/temp_install"

    # 4. Create/update the last_checked file
    touch "$LAST_CHECKED_FILE"
    LOG "Installation complete in $APP_HOME."
}


handle_update_check() {
    # 1. Check file age: older than $UPDATE_PERIOD days?
    # find command exits 0 and prints if a file matching criteria is found.
    # -mtime +N means modification time is older than N full 24-hour periods.
    if [ ! -f "$LAST_CHECKED_FILE" ] || find "$LAST_CHECKED_FILE" -mtime +$UPDATE_PERIOD -print -quit 2>/dev/null; then
        LOG "Checking for updates (last check older than $UPDATE_PERIOD days or file missing)..."

        # Record the modification time of the current archive before potential download
        local OLD_MTIME=$(get_file_mtime "$ARCHIVE_FILE")

        # 2. Conditional Download
        # -z "$ARCHIVE_FILE" tells curl to only download if the remote file is newer than the local one.
        # --remote-time (-r) ensures the new file uses the remote timestamp.
        LOG "Attempting conditional download..."

        # Use -w "%{http_code}" to capture the status code
        HTTP_CODE=$(curl -w "%{http_code}" -sSL --remote-time -z "$ARCHIVE_FILE" "$DOWNLOAD_URL" -o "$ARCHIVE_FILE")

        # 3. Check for successful download (HTTP 200) or successful conditional skip (HTTP 304 Not Modified)
        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            # Download successful (200 OK)
            LOG "New release downloaded."

            # Record the new modification time of the archive
            local NEW_MTIME=$(get_file_mtime "$ARCHIVE_FILE")

            # Check if the file timestamp actually changed (i.e., a newer file was downloaded)
            if [ "$NEW_MTIME" -ne "$OLD_MTIME" ]; then
                LOG "Archive file date changed (old=$OLD_MTIME, new=$NEW_MTIME). Unpacking update."
                # 4. Unpack the new release
                perform_full_install
            else
                LOG "Remote file was newer, but timestamp remained the same or file was skipped by curl -z. Skipping unpack."
            fi
        elif [ "$HTTP_CODE" -eq 304 ]; then
            # Conditional download skipped (304 Not Modified)
            LOG "No new release available (304 Not Modified)."
        else
            # Other error or redirection
            LOG "Conditional download failed or returned unexpected status code: $HTTP_CODE. Skipping update."
        fi

        # 5. Update last_checked timestamp regardless of success/failure of the update attempt
        touch "$LAST_CHECKED_FILE"
        LOG "Update check complete. Timestamp updated."
    else
        LOG "Skipping update check (last check within $UPDATE_PERIOD days)."
    fi
}

# --- Execution Flow ---

# 1. Installation/Update Check
if [ ! -f "$APP_EXE" ]; then
    perform_full_install
else
    # Ensure cache directory exists for the last_checked file
    mkdir -p "$CACHE_DIR" 2>/dev/null
    handle_update_check
fi

# 2. Execution Handover (The final requirement)
# Check if the currently executing script ($0) is NOT the application itself
# Use realpath to resolve symbolic links and get the canonical path
CURRENT_SCRIPT_PATH=$(realpath "$0")
BIN_EXE_PATH=$(realpath "$APP_EXE")

# Check if the current script path is NOT the path of the actual application executable
if [ "$CURRENT_SCRIPT_PATH" != "$BIN_EXE_PATH" ]; then
    LOG "Handing over execution to the installed application: $APP_EXE"
    # exec replaces the current script process with the application process
    exec "$APP_EXE" "$@"
fi

##########################################
# BELOW THIS POINT YOU PUT YOUR OWN CODE #
##########################################

# This part is the "whatever might be there" section.
LOG "Running inside the application's environment ($BIN_DIR)."

# Your application's main logic or final execution step would go here if this script
# *is* the final executable. Otherwise you can call out to other scripts or binaries as needed.

# For simplicity, we just print a success message and exit.
echo "------------------------------------"
echo "This is application: $APP_NAME"
echo "Arguments received : $@"
echo "------------------------------------"

exit 0
