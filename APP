#!/bin/bash

# --- Configuration (Non-Overridable) ---
APP_NAME="APP"
APP_DIR=".APP"
DOWNLOAD_URL="https://example.com/releases/.../foo-latest.tgz"
# ---------------------------------------

HOME_DIR="$HOME"

# Define essential directories
APP_HOME="$HOME_DIR/.local/share/$APP_DIR"
CONFIG_HOME="$HOME_DIR/.config/$APP_DIR"
CACHE_HOME="$HOME_DIR/.cache/$APP_DIR"
SHARED_BIN="$HOME_DIR/.local/bin"

# Define default overridable variables
# The update period in days (e.g., 3 means check if the last_checked file is older than 3 days)
UPDATE_PERIOD=3
# Logging level (0-ERROR, 1-WARN, 2-INFO, 3-DEBUG, empty disables logging)
LOG_LEVEL=1

# --- Configuration Loading ---
# Function to load configuration variables from a file
load_config() {
    local config_file="$1"
    if [ -f "$config_file" ]; then
        #LOG "Loading configuration from $config_file..."
        source "$config_file" 2>/dev/null
    fi
}

# Load user-wide configuration (if exists)
load_config "$CONFIG_HOME/bootstrap.cfg"

# Load local configuration (if exists)
load_config "./.$APP_DIR/bootstrap.cfg"

# LOG_LEVEL can be overridden by the user environment variable BS_LOG_LEVEL
LOG_LEVEL=${BS_LOG_LEVEL:-$LOG_LEVEL}

# -----------------------------

# Define the remaining path variables
HAP_DIR="$APP_HOME/bootstrap"
BAK_DIR="$HAP_DIR._bak_"
NEW_DIR="$HAP_DIR._new_"
BIN_DIR="$HAP_DIR/bin"
CCH_DIR="$CACHE_HOME/bootstrap"
TMP_DIR="$CCH_DIR/temp_install"
APP_SCRIPT="$BIN_DIR/$APP_NAME"
ARCHIVE_FILE="$CCH_DIR/release.tgz"
LAST_CHECKED_FILE="$CCH_DIR/last_checked"

# Helper function for logging
LOG_ERROR() {
    if [[ -n "$LOG_LEVEL" && "0" -le "$LOG_LEVEL" ]]; then
      echo "ERROR: $1"
    fi
}

LOG_INFO() {
    if [[ -n "$LOG_LEVEL" && "2" -le "$LOG_LEVEL" ]]; then
      echo "[$APP_NAME INFO] $1"
    fi
}

# --- Core Logic Functions ---

unpack_and_install() {
    # Unpack and clean up
    LOG_INFO "Unpacking application..."

    # Remove existing installation directory if it exists before unpacking
    rm -rf "$TMP_DIR"

    # Create a temporary directory for unpacking
    mkdir -p "$TMP_DIR"

    if ! tar -xzf "$ARCHIVE_FILE" -C "$TMP_DIR"; then
        LOG_ERROR "Failed to unpack archive $ARCHIVE_FILE"
        rm -rf "$TMP_DIR"
        return 1
    fi

    # Move all contents of temp_install to NEW_DIR
    LOG_INFO "Moving contents to $HAP_DIR"
    mkdir -p "$APP_HOME"
    mv "$TMP_DIR" "$NEW_DIR"

    # Replace the old app directory with the new one atomically
    mv "$HAP_DIR" "$BAK_DIR" 2>/dev/null || true
    mv "$NEW_DIR" "$HAP_DIR"
    rm -rf "$BAK_DIR"

    # Let's make sure the application script is executable
    if [[ -f "$APP_SCRIPT" ]]; then
        chmod +x "$APP_SCRIPT" 2>/dev/null || true
    fi

    # Copy application script(s) to shared bin
    LOG_INFO "Making application available in shared bin directory: $SHARED_BIN"
    mkdir -p "$SHARED_BIN"
    # We always copy the Bash script (it should exist), even on Windows
    cp -a "$APP_SCRIPT" "$SHARED_BIN/$APP_NAME"
    if [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "msys" ]]; then
        # On Windows we also copy the batch file (if it exists)
        if [[ -f "$APP_SCRIPT.cmd" ]]; then
            cp -a "$APP_SCRIPT.cmd" "$SHARED_BIN/$APP_NAME.cmd"
        fi
    fi

    # TODO: warn user when the app is not available in their PATH

    # Clean up the temporary directory
    rm -rf "$TMP_DIR"

    # Create/update the last_checked file
    touch "$LAST_CHECKED_FILE"
    LOG_INFO "Installation complete in $APP_HOME"
}

download_and_install() {
    # Check file age: older than $UPDATE_PERIOD days?
    # find command exits 0 and prints if a file matching criteria is found.
    # -mtime +N means modification time is older than N full 24-hour periods.
    if [ ! -f "$LAST_CHECKED_FILE" ] || [ -n "$(find "$LAST_CHECKED_FILE" -mtime +$UPDATE_PERIOD -print -quit 2>/dev/null)" ]; then
        LOG_INFO "Checking for updates [last check older than $UPDATE_PERIOD days or file missing]..."

        # Setup directories
        mkdir -p "$CCH_DIR" || { LOG_ERROR "Could not create cache directory $CCH_DIR"; return 1; }

        # Conditional Download
        # -z "$ARCHIVE_FILE" tells curl to only download if the remote file is newer than the local one.
        # --remote-time (-r) ensures the new file uses the remote timestamp.
        # Use -w "%{http_code}" to capture the status code
        HTTP_CODE=$(curl -w "%{http_code}" -sSL --remote-time -z "$ARCHIVE_FILE" "$DOWNLOAD_URL" -o "$ARCHIVE_FILE")
        LOG_INFO "Received HTTP code: $HTTP_CODE"

        # Check for successful download (HTTP 200) or successful conditional skip (HTTP 304 Not Modified)
        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            # Download successful
            LOG_INFO "New release downloaded"
            # Unpack the new release
            unpack_and_install
            return $?
        elif [ "$HTTP_CODE" -eq 304 ]; then
            # Conditional download skipped (304 Not Modified)
            LOG_INFO "No new release available [304 Not Modified]"
        else
            # Other error or redirection
            LOG_INFO "Conditional download failed or returned unexpected status code: $HTTP_CODE. Skipping update"
            return 1
        fi

        # Update last_checked timestamp regardless of success/failure of the update attempt
        touch "$LAST_CHECKED_FILE"
        LOG_INFO "Download/update check complete"
    else
        LOG_INFO "Skipping update check [last check within $UPDATE_PERIOD days]"
    fi
}

# --- Execution Flow ---

# Installation/Update Check
LOG_INFO "Check for executable $APP_SCRIPT"
if [ ! -f "$APP_SCRIPT" ]; then
    LOG_INFO "Application not found. Starting download and install..."
    download_and_install
    if [[ $? -ne 0 ]]; then
        LOG_ERROR "Installation of application failed!"
        exit 1
    fi
else
    LOG_INFO "Application found. Check if there is an update to install..."
    download_and_install
fi

# Execution Handover (The final requirement)
# Check if the currently executing script is NOT the application itself
# Use realpath to resolve symbolic links and get the canonical path
CURRENT_SCRIPT_PATH=$(realpath "$0")
BIN_EXE_PATH1=$(realpath "$APP_SCRIPT")
BIN_EXE_PATH2=$(realpath "$SHARED_BIN/$APP_NAME")

# Check if the current script path is NOT the path of the actual application executable
if [[ "$CURRENT_SCRIPT_PATH" != "$BIN_EXE_PATH1" && "$CURRENT_SCRIPT_PATH" != "$BIN_EXE_PATH2" ]]; then
    LOG_INFO "Handing over execution to the installed application: $APP_SCRIPT"
    # exec replaces the current script process with the application process
    exec "$APP_SCRIPT" "$@"
fi

##########################################
# BELOW THIS POINT YOU PUT YOUR OWN CODE #
##########################################

# This part is the "whatever might be there" section.
LOG_INFO "Running inside the application's environment [$BIN_DIR]"

# Your application's main logic or final execution step would go here if this script
# *is* the final executable. Otherwise you can call out to other scripts or binaries as needed.

# For simplicity, we just print a success message and exit.
echo "------------------------------------"
echo "This is application: $APP_NAME"
echo "Arguments received : $@"
echo "------------------------------------"

exit 0
