#!/bin/bash

# --- Configuration (Non-Overridable) ---
APP_NAME="dummy"
APP_DIR=".dummy-app"
DOWNLOAD_URL="https://github.com/codejive/bootstrap/releases/latest/download/release.tgz"
# ---------------------------------------

# Setup essential variables needed for config loading
HOME_DIR="$HOME"
APP_HOME="$HOME_DIR/$APP_DIR"

# Define default overridable variables
# The update period in days (e.g., 3 means check if the last_checked file is older than 3 days)
UPDATE_PERIOD=3
# Logging level (0-ERROR, 1-WARN, 2-INFO, 3-DEBUG, empty disables logging)
LOG_LEVEL=

# --- Configuration Loading ---
# Function to load configuration variables from a file
load_config() {
    local config_file="$1"
    if [ -f "$config_file" ]; then
        #LOG "Loading configuration from $config_file..."
        source "$config_file" 2>/dev/null
    fi
}

# Load user-wide configuration (if exists)
load_config "$APP_HOME/bootstrap.cfg"

# Load local configuration (if exists)
load_config "./$APP_DIR/bootstrap.cfg"

# -----------------------------

# Define the remaining path variables using the (potentially overridden) APP_NAME/UPDATE_PERIOD
CACHE_DIR="$APP_HOME/_cache"
HAP_DIR="$APP_HOME/app"
BIN_DIR="$HAP_DIR/bin"
APP_EXE="$BIN_DIR/$APP_NAME"
ARCHIVE_FILE="$CACHE_DIR/release.tgz"
LAST_CHECKED_FILE="$CACHE_DIR/last_checked"

# Helper function for logging
LOG_ERROR() {
    if [[ -n "$LOG_LEVEL" && "0" -ge "$LOG_LEVEL" ]]; then
      echo "ERROR: $1"
    fi
}

LOG_INFO() {
    if [[ -n "$LOG_LEVEL" && "2" -ge "$LOG_LEVEL" ]]; then
      echo "[$APP_NAME INFO] $1"
    fi
}

# --- Core Logic Functions ---

unpack_and_install() {
    # Unpack and clean up
    LOG_INFO "Unpacking application..."
    # Remove existing installation directory if it exists before unpacking
    rm -rf "$APP_HOME/temp_install"
    mkdir -p "$APP_HOME/temp_install"

    if ! tar -xzf "$ARCHIVE_FILE" -C "$APP_HOME/temp_install"; then
        LOG_ERROR "Failed to unpack archive $ARCHIVE_FILE"
        rm -rf "$APP_HOME/temp_install"
        return 1
    fi

    # Move all contents of temp_install to APP_HOME/app.new
    LOG_INFO "Moving contents to $HAP_DIR"
    mv "$APP_HOME/temp_install" "$HAP_DIR.new"

    # Replace the old app directory with the new one atomically
    mv "$HAP_DIR" "$HAP_DIR.bak" 2>/dev/null || true
    mv "$HAP_DIR.new" "$HAP_DIR"
    rm -rf "$HAP_DIR.bak"

    # Clean up the temporary directory
    rm -rf "$APP_HOME/temp_install"

    # Create/update the last_checked file
    touch "$LAST_CHECKED_FILE"
    LOG_INFO "Installation complete in $APP_HOME"
}

download_and_install() {
    # Check file age: older than $UPDATE_PERIOD days?
    # find command exits 0 and prints if a file matching criteria is found.
    # -mtime +N means modification time is older than N full 24-hour periods.
    if [ ! -f "$LAST_CHECKED_FILE" ] || [ -n "$(find "$LAST_CHECKED_FILE" -mtime +$UPDATE_PERIOD -print -quit 2>/dev/null)" ]; then
        LOG_INFO "Checking for updates [last check older than $UPDATE_PERIOD days or file missing]..."

        # Setup directories
        mkdir -p "$CACHE_DIR" || { LOG_ERROR "Could not create cache directory $CACHE_DIR"; return 1; }

        # Conditional Download
        # -z "$ARCHIVE_FILE" tells curl to only download if the remote file is newer than the local one.
        # --remote-time (-r) ensures the new file uses the remote timestamp.
        # Use -w "%{http_code}" to capture the status code
        HTTP_CODE=$(curl -w "%{http_code}" -sSL --remote-time -z "$ARCHIVE_FILE" "$DOWNLOAD_URL" -o "$ARCHIVE_FILE")
        LOG_INFO "Received HTTP code: $HTTP_CODE"

        # Check for successful download (HTTP 200) or successful conditional skip (HTTP 304 Not Modified)
        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            # Download successful
            LOG_INFO "New release downloaded"
            # Unpack the new release
            unpack_and_install
            return $?
        elif [ "$HTTP_CODE" -eq 304 ]; then
            # Conditional download skipped (304 Not Modified)
            LOG_INFO "No new release available [304 Not Modified]"
        else
            # Other error or redirection
            LOG_INFO "Conditional download failed or returned unexpected status code: $HTTP_CODE. Skipping update"
            return 1
        fi

        # Update last_checked timestamp regardless of success/failure of the update attempt
        touch "$LAST_CHECKED_FILE"
        LOG_INFO "Download/update check complete"
    else
        LOG_INFO "Skipping update check [last check within $UPDATE_PERIOD days]"
    fi
}

# --- Execution Flow ---

# Installation/Update Check
LOG_INFO "Check for executable $APP_EXE"
if [ ! -f "$APP_EXE" ]; then
    LOG_INFO "Application not found. Starting download and install..."
    download_and_install
    if [[ $? -ne 0 ]]; then
        LOG_ERROR "Installation of application failed!"
        exit 1
    fi
else
    LOG_INFO "Application found. Check if there is an update to install..."
    download_and_install
fi

# Execution Handover (The final requirement)
# Check if the currently executing script ($0) is NOT the application itself
# Use realpath to resolve symbolic links and get the canonical path
CURRENT_SCRIPT_PATH=$(realpath "$0")
BIN_EXE_PATH=$(realpath "$APP_EXE")

# Check if the current script path is NOT the path of the actual application executable
if [ "$CURRENT_SCRIPT_PATH" != "$BIN_EXE_PATH" ]; then
    LOG_INFO "Handing over execution to the installed application: $APP_EXE"
    # exec replaces the current script process with the application process
    exec "$APP_EXE" "$@"
fi

##########################################
# BELOW THIS POINT YOU PUT YOUR OWN CODE #
##########################################

# This part is the "whatever might be there" section.
LOG_INFO "Running inside the application's environment [$BIN_DIR]"

# Your application's main logic or final execution step would go here if this script
# *is* the final executable. Otherwise you can call out to other scripts or binaries as needed.

# For simplicity, we just print a success message and exit.
echo "------------------------------------"
echo "This is application: $APP_NAME"
echo "Arguments received : $@"
echo "------------------------------------"

exit 0
